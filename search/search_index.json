{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduzione","text":"<p>Il componente realizza una API REST per gestire le informazioni che riguardano le partite. In particolare, \u00e8 composta da:</p> <ul> <li>Rest server: componente principale dell'applicazione realizzato dal team;</li> <li>Prometheus: permette l'estrazione delle metriche dal rest-server con un sistema di monitoraggio periodico;</li> <li>Grafana: elabora le metriche estratte da Prometheus per la creazione di dashboard grafiche per misurare le performance dell'applicazione;</li> <li>Postgres: database relazionale necessario al funzionanmento dell'applicazione;</li> </ul> <p>Ad eccezione del rest-server e di postgres, tutti gli altri componenti sono opzionali.</p>"},{"location":"#struttura-progetto","title":"Struttura progetto","text":"<p>Il progetto segue presenta 3 cartelle principali:</p> <ul> <li>model: in cui ci sono le strutture che servono per interagire con il database;</li> <li>api: in cui per ogni entit\u00e0 (Game, Round ecc) sono implementati gli endpoint HTTP con le relative operazioni sul database;</li> <li>postman: in cui si trovano la specifica OpenAPI (<code>postman/schemas/index.yaml</code>) e la collection Postman <code>postman/collections/GameRepositoryCollection.json</code>;</li> </ul> <p>L'architettura dell'applicazione \u00e8 mostrata di seguito:</p> <p></p>"},{"location":"#dipendenze","title":"Dipendenze","text":"<p>In questa sezione, viene spiegato in dettaglio come \u00e8 stato sviluppato il componente rest-server. Il rest-server \u00e8 un'applicazione GO ed \u00e8 dotata di un <code>Makefile</code> per gestire il processo di sviluppo e compilazione. Per ottenere la lista di tutti i <code>target</code> disponibili:</p> <pre><code>make help\nUsage:\n\nbuild              builds the application in \"build\" directory\n  run                runs the application in \"build/game-repository\"\ndev                executes the application with hot reload\n  dev-dependecies    installs development dependencies\n  docker-build       builds a docker image\n  docker-run         runs a docker container. Needs \"config\" argument (i.e make docker-run config=$(pwd)/config.json)\ndocker-push-ssh    sends the image on a server with ssh (i.e make docker-push-ssh SSH=\"10.10.1.1 -p1234\")\ndocker-push        sends the image on a registry (i.e make docker-push REGISTRY=&lt;registry_name&gt;)\ntest               executes all unit tests in the repository. Use COVER_DIR=&lt;PATH&gt; to enable coverage. (i.e make test COVER_DIR=$(pwd)/coverage)\ntest-race          executes all unit tests with a race detector. Takes longer\n  test-integration   executes all tests. If CI is set, DB_URI can be used to set database URL, otherwis a docker container is used (i.e make test-integration CI=1 DB_URI=db-url COVER_DIR=/some/path)\nclean              remove build files\n  help               prints this help message\n</code></pre>"},{"location":"#installazione-toolchain-go","title":"Installazione toolchain GO","text":"<p>Dato che Go \u00e8 dotato di un runtime multipiattaforma, per installare la toolchain per il proprio sistema basta navigare sul sito ufficiale, scaricare la versione adatta al proprio sistema e seguire le istruzioni. In particolare, la versione utilizzata per sviluppare il progetto \u00e8 la <code>1.20.4</code>.</p>"},{"location":"#dipendenze-di-progetto","title":"Dipendenze di progetto","text":"<p>Visto che l'applicazione usa il <code>vendoring</code> delle dipendenze non \u00e8 necessario installare alcuna libreria. Per eseguire il testing dell'applicazione \u00e8 necessario avere a disposizione <code>docker</code>.</p>"},{"location":"#configurazione","title":"Configurazione","text":"<p>L'applicazione deve essere configurata con un file in formato <code>json</code> il cui path deve essere passato con l'argomento <code>--config=&lt;PATH&gt;</code>. Il comportamento default \u00e8 quello di cercare un file <code>config.json</code> all'interno della directory corrente. I valori di default della configurazione sono riportati nel file <code>config.example.json</code>.</p> <p><pre><code>{\n\"postgresUrl\": \"\",\n\"listenAddress\": \"localhost:3000\",\n\"apiPrefix\": \"/\",\n\"dataPath\": \"data\",\n\"enableSwagger\": false,\n\"rateLimiting\": {\n\"enabled\": false,\n\"burst\": 4,\n\"maxRate\": 2\n},\n\"authentication\": {\n\"enabled\": false,\n\"headerKey\": \"Authorization\",\n\"authEndpoint\": \"http://auth-service/auth\",\n\"method\": \"POST\"\n}\n}\n</code></pre> Prima di eseguire l'applicazione \u00e8 necessario creare un file di configurazione funzionante. In particolare, tutti i parametri specificati sopra sono opzionale ad eccezione di postgresUrl. Quindi, assicurandosi di avere un'istanza Postgres funzionante, bisogna creare un file di configurazione <code>config.json</code> nella cartella principale del progetto con il seguente contentuto:</p> config.json<pre><code>{\n\"postgresUrl\": \"&lt;POSTGRES_URL&gt;\",\n}\n</code></pre> <p>Ad esempio:</p> config.json<pre><code>{\n\"postgresUrl\": \"postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable\",\n}\n</code></pre>"},{"location":"#compilazione-ed-esecuzione","title":"Compilazione ed esecuzione","text":"<p>L'applicazione pu\u00f2 essere compilata con: <pre><code>make build\n</code></pre></p> <p>Mentre per eseguirla:</p> <pre><code>make run\n</code></pre> <p>Questo comando esegue l'applicazione cercando il file di configurazione nella cartella corrente. Per specificare un path custom:</p> <pre><code>make run CONFIG=&lt;PATH_TO_CONFIG&gt;\n</code></pre>"},{"location":"#compilazione-ed-esecuzione-con-docker","title":"Compilazione ed esecuzione con Docker","text":"<p>Per compilare un'immagine Docker:</p> <pre><code>make docker-build\n</code></pre> <p>Mentre per eseguirla:</p> <pre><code>make docker-run CONFIG=&lt;PATH_TO_CONFIG&gt;\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>L'applicazione prevede due tipi di testing:</p> <ul> <li>Unit testing: non hanno bisogno di un database;</li> <li>Integration testing: utilizza un database reale;</li> </ul> <p>Per effettuare unit testing: <pre><code>make test\n</code></pre></p> <p>Per effettuare integration testing, bisogna specificare l'indirizzo di un database:</p> <ul> <li>CI=1 se il flag <code>CI</code> \u00e8 settato, allora in <code>DB_URI</code> bisogna inserire l'indirizzo del database;</li> <li>CI non settato: viene creato un container usa e getta con Docker;</li> </ul> <p>Entrambe le versioni dei comandi hanno bisogno dell'argomento <code>COVER_DIR</code> necessario al calcolo delle metriche di copertura. Quindi un comando completo per il test di integrazione sar\u00e0:</p> <pre><code>make test-integration CI=1 DB_URI=postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable COVER_DIR=$(pwd)/coverage\n</code></pre> <p>Oppure se si preferisce utilizzare un database usa e getta:</p> <pre><code>make test-integration COVER_DIR=$(pwd)/coverage\n</code></pre>"},{"location":"installazione/","title":"Installazione (Rest Server only)","text":"<p>Ci sono diverse modalit\u00e0 per installare l'applicazione. In particolare, in questa sezione si far\u00e0 riferimento solo al rest-server.</p>"},{"location":"installazione/#docker-from-source","title":"Docker from source","text":"<p>Questa modalit\u00e0 crea un'immagine docker dal codice sorgente. Una volta effettuato il <code>clone</code> della repository eseguire il comando:</p> <pre><code>make docker-build\n</code></pre> <p>L'immagine avr\u00e0 il tag <code>game-repository:{git-commit}</code></p>"},{"location":"installazione/#push-su-un-docker-registry","title":"Push su un docker registry","text":"<p>L'immagine create pu\u00f2 essere salvata in un Docker registry. Una volta effettuato il login con <code>docker login</code>, pu\u00f2 essere effettuato il push con comando:</p> <p><pre><code>make docker-push REGISTRY=&lt;registry-name&gt;\n</code></pre> Questa azione effettua il push di due immagini, una con il tag latest e una con tag riferito al commit corrente. </p>"},{"location":"installazione/#push-con-ssh-unix-like-only","title":"Push con SSH (unix-like only)","text":"<p>Attenzione: questo comando utilizza le pipe tipiche delle shell unix e del programma pv (che mostra l'andamento dell'upload). Pertanto non \u00e8 disponibile in shell Windows.</p> <p>Per caricare l'immagine su un server SSH, bisogna assicurarsi che il server abbia un agente Docker installato correttamente. Poi eseguire il comando:</p> <pre><code>make docker-push-ssh SSH=\"10.10.0.1 -p1234\"\n</code></pre>"},{"location":"installazione/#binary-from-source","title":"Binary from source","text":"<p>Una volta effettuato il <code>clone</code> della repository e installata la GO toolchain eseguire il comando:</p> <pre><code>make build\n</code></pre> <p>L'applicazione si trover\u00e0 nella cartella <code>build</code>.</p>"},{"location":"installazione/#binary-from-release","title":"Binary from release","text":"<p>Una volta individuati l'architettura e il sistema operativo su cui deve essere eseguita l'applicazione \u00e8 possibile scaricare un pacchetto della versione rilasciata su Github. Ogni pacchetto (tar.gz per Linux/Mac e zip per Windows) contiene i seguenti file:</p> <ul> <li>game-repository: eseguibile dell'applicazione;</li> <li>README.md: file che punta a un'istanza demo e a questa documentazione;</li> <li>LICENSE: file di licenza;</li> <li>index.yaml: specifica OpenAPI;</li> <li>GameRepositoryCollection: collection da importare in Postman;</li> <li>config.example.json: esempio di configurazione;</li> </ul> <p>Le release sono disponibili al seguente link.</p>"},{"location":"installazione/#docker-release","title":"Docker release","text":"<p>Insieme ad ogni release, un'immagine docker viene salvata sul registry: <code>capas/game-repository</code>. Per scaricare l'immagine, eseguire: <pre><code>docker pull capas/game-repository\n</code></pre></p>"}]}